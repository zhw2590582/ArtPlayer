{"mappings":"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","sources":["packages/artplayer-plugin-websr/src/index.js","node_modules/@websr/websr/dist/websr.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js"],"sourcesContent":["import WebSR from '@websr/websr';\n\nexport default function artplayerPluginWebsr(option = {}) {\n    return (art) => {\n        const {\n            template: { $player },\n            constructor: {\n                validator,\n                utils: { append, setStyles },\n            },\n        } = art;\n\n        // Default options\n        option = validator(\n            {\n                scale: 2,\n                networkName: '',\n                weights: null,\n                compare: false,\n                ...option,\n            },\n            {\n                scale: 'number',\n                networkName: 'string',\n                weights: '?string|object',\n                compare: 'boolean',\n            }\n        );\n\n        // Validate required parameters\n        if (!option.networkName) {\n            console.error('WebSR: networkName is required');\n        }\n        if (!option.weights) {\n            console.error('WebSR: weights is required');\n        }\n\n        let websr = null;\n        let gpu = null;\n        let isInitialized = false;\n        let isEnabled = true;  // Always enabled\n        let renderFrameId = null;\n        let comparePosition = 0.5;  // Comparison split position (0-1)\n        let isCompareDragging = false;\n\n        // Create canvas for upscaled output\n        const $canvas = document.createElement('canvas');\n        $canvas.id = 'artplayer-websr-canvas';\n        setStyles($canvas, {\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            display: 'block',\n            pointerEvents: 'none',\n            zIndex: '11',\n            imageRendering: 'crisp-edges',\n        });\n        append($player, $canvas);\n\n        // Create comparison divider\n        const $compareDivider = document.createElement('div');\n        $compareDivider.id = 'artplayer-websr-divider';\n        setStyles($compareDivider, {\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            width: '2px',\n            height: '100%',\n            backgroundColor: '#fff',\n            display: option.compare ? 'block' : 'none',\n            pointerEvents: 'auto',\n            cursor: 'col-resize',\n            zIndex: '12',\n        });\n        append($player, $compareDivider);\n\n        // Function to update divider position and canvas clip-path\n        function updateDividerPosition(pos) {\n            comparePosition = Math.max(0, Math.min(1, pos));\n            const offsetX = comparePosition * 100;\n            setStyles($compareDivider, {\n                left: offsetX + '%',\n            });\n            \n            // Update canvas clip-path to show only right side (upscaled)\n            if (option.compare) {\n                const clipPercent = comparePosition * 100;\n                setStyles($canvas, {\n                    clipPath: `inset(0 0 0 ${clipPercent}%)`,\n                });\n            }\n        }\n\n        // Mouse events for comparison dragging\n        document.addEventListener('mousemove', (e) => {\n            if (!isCompareDragging) return;\n            const rect = $player.getBoundingClientRect();\n            const pos = (e.clientX - rect.left) / rect.width;\n            updateDividerPosition(pos);\n        });\n\n        document.addEventListener('mouseup', () => {\n            isCompareDragging = false;\n        });\n\n        $compareDivider.addEventListener('mousedown', () => {\n            isCompareDragging = true;\n        });\n\n        // Touch events for mobile\n        document.addEventListener('touchmove', (e) => {\n            if (!isCompareDragging) return;\n            const rect = $player.getBoundingClientRect();\n            const pos = (e.touches[0].clientX - rect.left) / rect.width;\n            updateDividerPosition(pos);\n        }, { passive: true });\n\n        document.addEventListener('touchend', () => {\n            isCompareDragging = false;\n        });\n\n        $compareDivider.addEventListener('touchstart', () => {\n            isCompareDragging = true;\n        });\n\n        // Function to calculate canvas size based on video aspect ratio\n        function calcCanvasSize() {\n            const videoElement = art.video;\n            if (!videoElement) {\n                return { displayWidth: 640, displayHeight: 360 };\n            }\n\n            const containerWidth = $player.offsetWidth || 640;\n            const containerHeight = $player.offsetHeight || 360;\n            const videoWidth = videoElement.videoWidth || 640;\n            const videoHeight = videoElement.videoHeight || 360;\n            const aspectRatio = videoWidth / videoHeight;\n\n            let displayWidth = containerWidth;\n            let displayHeight = containerHeight;\n\n            if (containerWidth / containerHeight > aspectRatio) {\n                // Container is wider than video\n                displayWidth = containerHeight * aspectRatio;\n            } else {\n                // Container is taller than video\n                displayHeight = containerWidth / aspectRatio;\n            }\n\n            return { displayWidth, displayHeight };\n        }\n\n        // Initialize WebGPU and WebSR\n        async function initWebSR() {\n            try {\n                if (isInitialized) return true;\n\n                // Check WebGPU support\n                if (!navigator.gpu) {\n                    console.warn('WebGPU is not supported');\n                    return false;\n                }\n\n                // Initialize WebGPU\n                gpu = await WebSR.initWebGPU();\n                if (!gpu) {\n                    console.warn('Failed to initialize WebGPU');\n                    return false;\n                }\n\n                // Load weights\n                let weights;\n                if (typeof option.weights === 'string') {\n                    // If weights is a URL, fetch it\n                    const weightResponse = await fetch(option.weights);\n                    if (!weightResponse.ok) {\n                        console.warn(`Failed to load weights from ${option.weights}`);\n                        return false;\n                    }\n                    weights = await weightResponse.json();\n                } else if (typeof option.weights === 'object') {\n                    // If weights is an object, use it directly\n                    weights = option.weights;\n                } else {\n                    console.warn('Invalid weights format');\n                    return false;\n                }\n\n                // Create WebSR instance\n                const videoElement = art.video;\n                if (!videoElement) {\n                    console.warn('Video element not found');\n                    return false;\n                }\n\n                // Set canvas dimensions based on video aspect ratio\n                const { displayWidth, displayHeight } = calcCanvasSize();\n                $canvas.width = displayWidth * option.scale;\n                $canvas.height = displayHeight * option.scale;\n                setStyles($canvas, {\n                    width: displayWidth + 'px',\n                    height: displayHeight + 'px',\n                });\n\n                websr = new WebSR({\n                    source: videoElement,\n                    network_name: option.networkName,\n                    weights: weights,\n                    gpu: gpu,\n                    canvas: $canvas,\n                });\n\n                isInitialized = true;\n                return true;\n            } catch (error) {\n                console.error('WebSR initialization error:', error);\n                return false;\n            }\n        }\n\n        // Render single frame\n        async function renderSingleFrame() {\n            if (!websr || !isEnabled || !art.video) {\n                return;\n            }\n\n            try {\n                await websr.render(art.video);\n            } catch (error) {\n                console.error('WebSR render error:', error);\n            }\n        }\n\n        // Render frame function\n        async function renderFrame() {\n            if (!websr || !isEnabled || !art.video || art.video.paused) {\n                renderFrameId = null;\n                return;\n            }\n\n            try {\n                await websr.render(art.video);\n            } catch (error) {\n                console.error('WebSR render error:', error);\n            }\n\n            // Continue rendering\n            if (isEnabled && !art.video.paused) {\n                renderFrameId = requestAnimationFrame(renderFrame);\n            }\n        }\n\n        // Enable WebSR\n        async function enable() {\n            if (isEnabled) return;\n\n            if (!isInitialized) {\n                const initialized = await initWebSR();\n                if (!initialized) {\n                    console.error('Failed to initialize WebSR');\n                    return;\n                }\n            }\n\n            isEnabled = true;\n            setStyle($canvas, 'display', 'block');\n\n            // Start rendering if video is playing\n            if (art.video && !art.video.paused) {\n                renderFrameId = requestAnimationFrame(renderFrame);\n            }\n\n            art.emit('artplayerPluginWebsr:enable');\n        }\n\n        // Disable WebSR\n        function disable() {\n            if (!isEnabled) return;\n\n            isEnabled = false;\n            setStyles($canvas, {\n                display: 'none',\n            });\n\n            // Cancel ongoing render\n            if (renderFrameId) {\n                cancelAnimationFrame(renderFrameId);\n                renderFrameId = null;\n            }\n\n            art.emit('artplayerPluginWebsr:disable');\n        }\n\n        // Toggle WebSR\n        async function toggle() {\n            if (isEnabled) {\n                disable();\n            } else {\n                await enable();\n            }\n        }\n\n        // Listen to video events\n        art.on('play', () => {\n            renderSingleFrame();  // Render current frame immediately\n            if (isEnabled && isInitialized && !renderFrameId) {\n                renderFrameId = requestAnimationFrame(renderFrame);\n            }\n        });\n\n        art.on('pause', () => {\n            if (renderFrameId) {\n                cancelAnimationFrame(renderFrameId);\n                renderFrameId = null;\n            }\n        });\n\n        art.on('seek', () => {\n            if (isEnabled && isInitialized && !art.video.paused && !renderFrameId) {\n                renderFrameId = requestAnimationFrame(renderFrame);\n            }\n        });\n\n        art.on('resize', () => {\n            if (websr && $canvas.offsetParent) {\n                const { displayWidth, displayHeight } = calcCanvasSize();\n                $canvas.width = displayWidth * option.scale;\n                $canvas.height = displayHeight * option.scale;\n                setStyles($canvas, {\n                    width: displayWidth + 'px',\n                    height: displayHeight + 'px',\n                });\n            }\n        });\n\n        art.on('destroy', () => {\n            disable();\n            if (renderFrameId) {\n                cancelAnimationFrame(renderFrameId);\n                renderFrameId = null;\n            }\n            if ($canvas.parentNode) {\n                $canvas.parentNode.removeChild($canvas);\n            }\n        });\n\n        // Initialize if enabled by default\n        initWebSR().then(() => {\n            // Render first frame after initialization\n            if (isEnabled && isInitialized && art.video) {\n                renderSingleFrame();\n            }\n        }).catch(err => console.error('Failed to init WebSR:', err));\n\n        // Return plugin API\n        return {\n            name: 'artplayerPluginWebsr',\n            websr: () => websr,\n            gpu: () => gpu,\n            canvas: () => $canvas,\n            enable,\n            disable,\n            toggle,\n            isEnabled: () => isEnabled,\n            isInitialized: () => isInitialized,\n            // Comparison mode methods\n            enableCompare: () => {\n                option.compare = true;\n                setStyles($compareDivider, { display: 'block' });\n                updateDividerPosition(comparePosition);\n            },\n            disableCompare: () => {\n                option.compare = false;\n                setStyles($compareDivider, { display: 'none' });\n                setStyles($canvas, { clipPath: 'none' });\n            },\n            toggleCompare: () => {\n                if (option.compare) {\n                    setStyles($compareDivider, { display: 'none' });\n                    setStyles($canvas, { clipPath: 'none' });\n                    option.compare = false;\n                } else {\n                    option.compare = true;\n                    setStyles($compareDivider, { display: 'block' });\n                    updateDividerPosition(comparePosition);\n                }\n            },\n            setComparePosition: (pos) => {\n                updateDividerPosition(pos);\n            },\n            getComparePosition: () => comparePosition,\n            isComparing: () => option.compare,\n            update: async (newOption) => {\n                // Update weights and networkName (requires re-initialization)\n                if ((newOption.weights !== undefined && newOption.weights !== option.weights) ||\n                    (newOption.networkName !== undefined && newOption.networkName !== option.networkName)) {\n                    // Update option values\n                    if (newOption.weights !== undefined) {\n                        option.weights = newOption.weights;\n                    }\n                    if (newOption.networkName !== undefined) {\n                        option.networkName = newOption.networkName;\n                    }\n                    // Mark as uninitialized to reload with new config\n                    isInitialized = false;\n                    // Reinitialize if enabled\n                    if (isEnabled) {\n                        await initWebSR();\n                    }\n                }\n\n                // Update scale factor\n                if (newOption.scale !== undefined && newOption.scale !== option.scale) {\n                    option.scale = newOption.scale;\n                    if ($canvas) {\n                        const { displayWidth, displayHeight } = calcCanvasSize();\n                        $canvas.width = displayWidth * option.scale;\n                        $canvas.height = displayHeight * option.scale;\n                        setStyles($canvas, {\n                            width: displayWidth + 'px',\n                            height: displayHeight + 'px',\n                        });\n                    }\n                }\n            },\n        };\n    };\n}\n\nif (typeof window !== 'undefined') {\n    window.artplayerPluginWebsr = artplayerPluginWebsr;\n}\n","/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebSR\"] = factory();\n\telse\n\t\troot[\"WebSR\"] = factory();\n})(self, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./src/context.ts\":\n/*!************************!*\\\n  !*** ./src/context.ts ***!\n  \\************************/\n/***/ (function(__unused_webpack_module, exports) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nclass WebGPUContext {\\n    constructor(device, resolution, canvas, scale, debug) {\\n        this.device = device;\\n        this.canvas = canvas;\\n        this.resolution = resolution;\\n        this.textures = {};\\n        this.buffers = {};\\n        this.destroyed = false;\\n        this.scale = scale;\\n        this.debug = debug;\\n        let context = this.canvas.getContext('webgpu');\\n        if (context instanceof GPUCanvasContext) {\\n            this.context = context;\\n        }\\n        else {\\n            throw new Error(\\\"Unable to load WebGPU context\\\");\\n        }\\n        this.context.configure({\\n            device: this.device,\\n            format: navigator.gpu.getPreferredCanvasFormat()\\n        });\\n        this.textureUsage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;\\n        this.bufferUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\\n        if (this.debug) {\\n            // Read output pixel value\\n            this.textureUsage = this.textureUsage | GPUTextureUsage.COPY_SRC;\\n            this.bufferUsage = this.bufferUsage | GPUBufferUsage.COPY_SRC;\\n        }\\n        this.textures['output'] = this.context.getCurrentTexture();\\n    }\\n    readBuffer(bufferName) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (!this.buffers[bufferName])\\n                throw new Error(`No buffer with name ${bufferName}`);\\n            const readEncoder = this.device.createCommandEncoder({\\n                label: `Read ${bufferName} buffer encoder`,\\n            });\\n            const buffer = this.buffers[bufferName];\\n            const resultBuffer = this.device.createBuffer({\\n                label: 'result buffer',\\n                size: buffer.size,\\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\\n            });\\n            readEncoder.copyBufferToBuffer(buffer, 0, resultBuffer, 0, resultBuffer.size);\\n            this.device.queue.submit([readEncoder.finish()]);\\n            yield resultBuffer.mapAsync(GPUMapMode.READ);\\n            let range = resultBuffer.getMappedRange();\\n            return new Float32Array(range);\\n        });\\n    }\\n    readTexture(textureName) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (!this.textures[textureName])\\n                throw new Error(`No texture with name ${textureName}`);\\n            const readEncoder = this.device.createCommandEncoder({\\n                label: `Read ${textureName} texture encoder`,\\n            });\\n            const texture = this.textures[textureName];\\n            let bitsPerPixel = 16;\\n            if (texture.format === 'rgba8unorm')\\n                bitsPerPixel = 4;\\n            if (texture.format === 'r32float')\\n                bitsPerPixel = 4;\\n            const resultBuffer = this.device.createBuffer({\\n                label: 'result buffer',\\n                size: texture.width * texture.height * bitsPerPixel,\\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\\n            });\\n            readEncoder.copyTextureToBuffer({\\n                texture: this.textures[textureName],\\n            }, {\\n                buffer: resultBuffer,\\n                bytesPerRow: texture.width * bitsPerPixel\\n            }, {\\n                width: texture.width,\\n                height: texture.height,\\n                depthOrArrayLayers: 1,\\n            });\\n            this.device.queue.submit([readEncoder.finish()]);\\n            yield resultBuffer.mapAsync(GPUMapMode.READ);\\n            if (texture.format === 'r32float')\\n                return new Float32Array(resultBuffer.getMappedRange());\\n            else if (texture.format === 'rgba32float')\\n                return new Float32Array(resultBuffer.getMappedRange());\\n            else if (texture.format === 'rgba8unorm')\\n                return new Uint8ClampedArray(resultBuffer.getMappedRange());\\n            return new Float32Array(0);\\n        });\\n    }\\n    destroy() {\\n        this.device.destroy();\\n        this.destroyed = true;\\n    }\\n    buffer(key, options) {\\n        if (!this.buffers[key]) {\\n            options = options || {};\\n            const width = options.width || this.resolution.width;\\n            const height = options.height || this.resolution.height;\\n            const channels = options.channels || 4;\\n            const bitdepth = options.bitdepth || 4;\\n            this.buffers[key] = this.device.createBuffer({\\n                label: key,\\n                size: width * height * channels * bitdepth,\\n                usage: this.bufferUsage\\n            });\\n        }\\n        return this.buffers[key];\\n    }\\n    texture(key, options) {\\n        if (!this.textures[key]) {\\n            options = options || {};\\n            this.textures[key] = this.device.createTexture({\\n                label: key,\\n                size: [options.width || this.resolution.width, options.height || this.resolution.height],\\n                format: options.format || 'rgba32float',\\n                usage: this.textureUsage\\n            });\\n        }\\n        return this.textures[key];\\n    }\\n}\\nexports[\\\"default\\\"] = WebGPUContext;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/context.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-112x4.ts\":\n/*!********************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-112x4.ts ***!\n  \\********************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv112x4 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights, first) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv112x4\\\";\\n        const kernels = weights.weights;\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 28>\\\");\\n        let read_buffers = '';\\n        for (let i = 0; i < 7; i++) {\\n            if (first) {\\n                read_buffers += `\\n                let pixel_val${i} = inputBuffer${i}[buff_ind];\\n                result += kernels[${4 * i}]*max(pixel_val${i}, vec4f(0.0));\\n                result += kernels[${4 * i + 2}]*max(-1.0*pixel_val${i}, vec4f(0.0));\\n            `;\\n            }\\n            else {\\n                read_buffers += `\\n                let pixel_val${i} = inputBuffer${i}[buff_ind];\\n                result += kernels[${4 * i + 1}]*max(pixel_val${i}, vec4f(0.0));\\n                result += kernels[${4 * i + 3}]*max(-1.0*pixel_val${i}, vec4f(0.0));`;\\n            }\\n        }\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n               \\n                let buff_ind = coord.y*${this.resolution.width} + coord.x;\\n                ${read_buffers}\\n                \\n                outputBuffer[i] = result;\\n          }\\n        `);\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.defaultSetup();\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            compute: {\\n                module: this.shader,\\n                entryPoint: 'main',\\n            },\\n        };\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        this.uniforms.forEach((uniform, i) => {\\n            entries.push({\\n                binding: i + this.inputs.length,\\n                resource: {\\n                    buffer: this.buffers[uniform.name]\\n                }\\n            });\\n        });\\n        if (this.output instanceof GPUBuffer) {\\n            entries.push({\\n                binding: this.inputs.length + this.uniforms.length,\\n                resource: {\\n                    buffer: this.output\\n                }\\n            });\\n        }\\n        if (entries.length === 0)\\n            return null;\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv112x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-112x4.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-16x4.ts\":\n/*!*******************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-16x4.ts ***!\n  \\*******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv16x4 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv16x4\\\";\\n        const kernels = weights.weights;\\n        const bias = weights.bias;\\n        this.createUniform(\\\"kernel_offsets\\\", \\\"array<vec4f, 9>\\\");\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 36>\\\");\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n                      \\n                 for(var i = 0u; i < 9; i++){\\n                   let pixel_loc = coord + vec2<i32>(kernel_offsets[i].xy);\\n                   let buff_ind = pixel_loc.y*${this.resolution.width} + pixel_loc.x;\\n                   \\n                   let pix_val0 = inputBuffer0[buff_ind];\\n                   let pix_val1 = inputBuffer1[buff_ind];\\n                  \\n                   result += kernels[i]*max(pix_val0, vec4f(0.0));\\n                   result += kernels[i+9]*max(pix_val1, vec4f(0.0));\\n                   result += kernels[i+18]*max(-1.0*pix_val0, vec4f(0.0));\\n                   result += kernels[i+27]*max(-1.0*pix_val1, vec4f(0.0));\\n                 } \\n                 \\n\\n                    \\n                result += bias;\\n                \\n                outputBuffer[i] = result;\\n          }\\n        `);\\n        this.setUniform(\\\"kernel_offsets\\\", new Float32Array([\\n            -1, -1, 0, 0,\\n            -1, 0, 0, 0,\\n            -1, 1, 0, 0,\\n            0, -1, 0, 0,\\n            0, 0, 0, 0,\\n            0, 1, 0, 0,\\n            1, -1, 0, 0,\\n            1, 0, 0, 0,\\n            1, 1, 0, 0,\\n        ]));\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv16x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-16x4.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-3x4.ts\":\n/*!******************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-3x4.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv3x4 extends base_compute_layer_1.default {\\n    constructor(inputTextures, outputBuffer, weights) {\\n        super(inputTextures, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv3x4\\\";\\n        const kernels = weights.weights;\\n        const bias = weights.bias;\\n        this.createUniform(\\\"kernel_offsets\\\", \\\"array<vec4f, 9>\\\");\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 9>\\\");\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        // Set up pipeline in Lazy Load\\n        this.setUniform(\\\"kernel_offsets\\\", new Float32Array([\\n            -1, -1, 0, 0,\\n            -1, 0, 0, 0,\\n            -1, 1, 0, 0,\\n            0, -1, 0, 0,\\n            0, 0, 0, 0,\\n            0, 1, 0, 0,\\n            1, -1, 0, 0,\\n            1, 0, 0, 0,\\n            1, 1, 0, 0,\\n        ]));\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n    }\\n    lazyLoadSetup() {\\n        const externalTexture = this.inputs[0] instanceof GPUExternalTexture;\\n        const textureLoad = externalTexture ? 'textureLoad(inputTexture0, coord + offset)' :\\n            'textureLoad(inputTexture0, coord + offset, 0)';\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n                      \\n                 for(var i = 0u; i < 9; i++){\\n                   let offset = vec2<i32>(kernel_offsets[i].xy);\\n                   result += kernels[i]*${textureLoad};\\n                 } \\n                    \\n                result += bias;\\n                \\n                outputBuffer[i] = result;\\n          }\\n        `);\\n        this.pipeline = this.device.createComputePipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv3x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-3x4.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-56x4.ts\":\n/*!*******************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-56x4.ts ***!\n  \\*******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv56x4 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv56x4\\\";\\n        const kernels = weights.weights;\\n        const bias = weights.bias;\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 14>\\\");\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        let read_buffers = '';\\n        for (let i = 0; i < 7; i++) {\\n            read_buffers += `\\n            let pixel_val${i} = inputBuffer${i}[buff_ind];\\n            result += kernels[${2 * i}]*max(pixel_val${i}, vec4f(0.0));\\n            result += kernels[${2 * i + 1}]*max(-1.0*pixel_val${i}, vec4f(0.0));\\n            `;\\n        }\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n               \\n                let buff_ind = coord.y*${this.resolution.width} + coord.x;\\n                ${read_buffers}\\n                      \\n                result += bias;\\n                \\n                outputBuffer[buff_ind] = result;\\n          }\\n        `);\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n        this.defaultSetup();\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            compute: {\\n                module: this.shader,\\n                entryPoint: 'main',\\n            },\\n        };\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        this.uniforms.forEach((uniform, i) => {\\n            entries.push({\\n                binding: i + this.inputs.length,\\n                resource: {\\n                    buffer: this.buffers[uniform.name]\\n                }\\n            });\\n        });\\n        if (this.output instanceof GPUBuffer) {\\n            entries.push({\\n                binding: this.inputs.length + this.uniforms.length,\\n                resource: {\\n                    buffer: this.output\\n                }\\n            });\\n        }\\n        if (entries.length === 0)\\n            return null;\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv56x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-56x4.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-8x4.ts\":\n/*!******************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-8x4.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv8x4 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv8x4\\\";\\n        const kernels = weights.weights;\\n        const bias = weights.bias;\\n        this.createUniform(\\\"kernel_offsets\\\", \\\"array<vec4f, 9>\\\");\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 18>\\\");\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n                      \\n                 for(var i = 0u; i < 9; i++){\\n                   let pixel_loc = coord + vec2<i32>(kernel_offsets[i].xy);\\n                   let buff_ind = pixel_loc.y*${this.resolution.width} + pixel_loc.x;\\n                   \\n                   let pix_val = inputBuffer0[buff_ind];\\n                  \\n                   result += kernels[i]*max(pix_val, vec4f(0.0));\\n                   result += kernels[i+9]*max(-1.0*pix_val, vec4f(0.0));\\n                 } \\n                    \\n                result += bias;\\n                \\n                outputBuffer[i] = result;\\n          }\\n        `);\\n        this.setUniform(\\\"kernel_offsets\\\", new Float32Array([\\n            -1, -1, 0, 0,\\n            -1, 0, 0, 0,\\n            -1, 1, 0, 0,\\n            0, -1, 0, 0,\\n            0, 0, 0, 0,\\n            0, 1, 0, 0,\\n            1, -1, 0, 0,\\n            1, 0, 0, 0,\\n            1, 1, 0, 0,\\n        ]));\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv8x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-8x4.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-concat2.ts\":\n/*!**********************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-concat2.ts ***!\n  \\**********************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConcat2 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConcat2\\\";\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        const bias = weights.bias;\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n               \\n                let buff_ind = coord.y*${this.resolution.width} + coord.x;\\n               \\n                outputBuffer[buff_ind] = inputBuffer0[buff_ind] + inputBuffer1[buff_ind] + bias;\\n          }\\n        `);\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConcat2;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-concat2.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/display.ts\":\n/*!***************************************!*\\\n  !*** ./src/layers/anime4k/display.ts ***!\n  \\***************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass DisplayLayer extends base_render_layer_1.default {\\n    constructor(inputs, output) {\\n        super(inputs, output);\\n        this.label = \\\"DisplayLayer\\\";\\n        this.vertexScale = {\\n            width: 1,\\n            height: 1\\n        };\\n        this.sampler = this.device.createSampler({\\n            addressModeU: \\\"repeat\\\",\\n            addressModeV: \\\"repeat\\\",\\n            magFilter: \\\"linear\\\",\\n            minFilter: \\\"linear\\\",\\n            mipmapFilter: \\\"linear\\\",\\n        });\\n    }\\n    lazyLoadSetup() {\\n        const externalTexture = this.inputs[1] instanceof GPUExternalTexture;\\n        const textureLoad = externalTexture ? 'textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord)' :\\n            'textureSample(inputTexture, ourSampler, input.tex_coord)';\\n        this.shader = this.device.createShaderModule({\\n            label: `${this.label}-shader`,\\n            code: `\\n                \\n                   ${this.defaultVertexShader()}\\n                   @group(0) @binding(0) var<storage, read_write> inputBuffer0: array<vec4f>;\\n                   @group(0) @binding(1) var inputTexture: ${externalTexture ? 'texture_external' : 'texture_2d<f32>'};\\n                   @group(0) @binding(2) var ourSampler: sampler;\\n                  \\n                   @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\\n                      \\n                        let x = ${this.resolution.width}.0*(input.tex_coord.x);\\n                        let y = ${this.resolution.height}.0*(input.tex_coord.y);\\n                        \\n                        let y2 = u32(floor(y));\\n                        let x2 = u32(floor(x));\\n                        \\n                        let i = y2*${Math.floor(this.resolution.width)} +  x2;\\n                       \\n                        let x_floor  = u32(fract(x)*2.0);\\n                        let y_floor  = u32(fract(y)*2.0);\\n                        \\n                        //I don t know, I think this is right? I found this by trial and error\\n                        let c_index: u32 = x_floor + y_floor*2;  \\n        \\n                        let value = inputBuffer0[i][c_index];\\n                        \\n                        let bicubic = ${textureLoad};\\n                        \\n                        return bicubic + vec4f(value);\\n                    \\n                      }            \\n            `\\n        });\\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        entries.push({ binding: this.inputs.length, resource: this.sampler });\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = DisplayLayer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/display.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/display_1x.ts\":\n/*!******************************************!*\\\n  !*** ./src/layers/anime4k/display_1x.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass DisplayLayer extends base_render_layer_1.default {\\n    constructor(inputs, output) {\\n        super(inputs, output);\\n        this.label = \\\"DisplayLayer\\\";\\n        this.vertexScale = {\\n            width: 1,\\n            height: 1\\n        };\\n        this.sampler = this.device.createSampler({\\n            addressModeU: \\\"repeat\\\",\\n            addressModeV: \\\"repeat\\\",\\n            magFilter: \\\"linear\\\",\\n            minFilter: \\\"linear\\\",\\n            mipmapFilter: \\\"linear\\\",\\n        });\\n    }\\n    lazyLoadSetup() {\\n        const externalTexture = this.inputs[1] instanceof GPUExternalTexture;\\n        const textureLoad = externalTexture ? 'textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord)' :\\n            'textureSample(inputTexture, ourSampler, input.tex_coord)';\\n        this.shader = this.device.createShaderModule({\\n            label: `${this.label}-shader`,\\n            code: `\\n                \\n                   ${this.defaultVertexShader()}\\n                   @group(0) @binding(0) var<storage, read_write> inputBuffer0: array<vec4f>;\\n                   @group(0) @binding(1) var inputTexture: ${externalTexture ? 'texture_external' : 'texture_2d<f32>'};\\n                   @group(0) @binding(2) var ourSampler: sampler;\\n                  \\n                   @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\\n                      \\n                        let x = ${this.resolution.width}.0*(input.tex_coord.x);\\n                        let y = ${this.resolution.height}.0*(input.tex_coord.y);\\n                        \\n                        let y2 = u32(floor(y));\\n                        let x2 = u32(floor(x));\\n                        \\n                        let i = y2*${Math.floor(this.resolution.width)} +  x2;\\n      \\n                        let bicubic = ${textureLoad};\\n                        \\n                        return bicubic + inputBuffer0[i];\\n                    \\n                      }            \\n            `\\n        });\\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        entries.push({ binding: this.inputs.length, resource: this.sampler });\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = DisplayLayer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/display_1x.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/display_3c.ts\":\n/*!******************************************!*\\\n  !*** ./src/layers/anime4k/display_3c.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass DisplayLayer3C extends base_render_layer_1.default {\\n    constructor(inputs, output) {\\n        super(inputs, output);\\n        this.label = \\\"DisplayLayer3C\\\";\\n        this.vertexScale = {\\n            width: 1,\\n            height: 1\\n        };\\n        this.sampler = this.device.createSampler({\\n            addressModeU: \\\"repeat\\\",\\n            addressModeV: \\\"repeat\\\",\\n            magFilter: \\\"linear\\\",\\n            minFilter: \\\"linear\\\",\\n            mipmapFilter: \\\"linear\\\",\\n        });\\n    }\\n    lazyLoadSetup() {\\n        const externalTexture = this.inputs[3] instanceof GPUExternalTexture;\\n        const textureLoad = externalTexture ? 'textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord)' :\\n            'textureSample(inputTexture, ourSampler, input.tex_coord)';\\n        this.shader = this.device.createShaderModule({\\n            label: `${this.label}-shader`,\\n            code: `\\n                \\n                   ${this.defaultVertexShader()}\\n                   @group(0) @binding(0) var<storage, read_write> inputBuffer0: array<vec4f>;\\n                   @group(0) @binding(1) var<storage, read_write> inputBuffer1: array<vec4f>;\\n                   @group(0) @binding(2) var<storage, read_write> inputBuffer2: array<vec4f>;\\n                   @group(0) @binding(3) var inputTexture: ${externalTexture ? 'texture_external' : 'texture_2d<f32>'};\\n                   @group(0) @binding(4) var ourSampler: sampler;\\n                  \\n                   @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\\n                      \\n                        let x = ${this.resolution.width}.0*(input.tex_coord.x);\\n                        let y = ${this.resolution.height}.0*(input.tex_coord.y);\\n                        \\n                        let y2 = u32(floor(y));\\n                        let x2 = u32(floor(x));\\n                        \\n                        let i = y2*${Math.floor(this.resolution.width)} +  x2;\\n                       \\n                        let x_floor  = u32(fract(x)*2.0);\\n                        let y_floor  = u32(fract(y)*2.0);\\n                        \\n                        //I don t know, I think this is right? I found this by trial and error\\n                        let c_index: u32 = x_floor + y_floor*2;  \\n        \\n                        let value = inputBuffer0[i][c_index];\\n                        let value1 = inputBuffer1[i][c_index];\\n                        let value2 = inputBuffer2[i][c_index];\\n                        \\n                        let bicubic = ${textureLoad};\\n                        \\n                        return bicubic + vec4f(value, value1, value2, value2);\\n                    \\n                      }            \\n            `\\n        });\\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            vertex: {\\n                module: this.shader,\\n                entryPoint: 'vertexMain',\\n            },\\n            fragment: {\\n                module: this.shader,\\n                entryPoint: 'fragmentMain',\\n                targets: [{ format: this.output.format }],\\n            },\\n        };\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        entries.push({ binding: this.inputs.length, resource: this.sampler });\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = DisplayLayer3C;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/display_3c.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/base_compute_layer.ts\":\n/*!******************************************!*\\\n  !*** ./src/layers/base_compute_layer.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_layer_1 = __webpack_require__(/*! ./base_layer */ \\\"./src/layers/base_layer.ts\\\");\\nclass ComputeLayer extends base_layer_1.default {\\n    constructor(inputTextures, outputBuffer, weights) {\\n        super(inputTextures, outputBuffer, weights);\\n        this.num_work_groups = 8;\\n    }\\n    createStandardShader(computeShader) {\\n        return this.device.createShaderModule({\\n            label: `${this.label}-shader`,\\n            code: `\\n              \\n              ${this.computeShaderInputs()}\\n              \\n              ${computeShader}\\n        `\\n        });\\n    }\\n    computeShaderInputs() {\\n        const inputs = [];\\n        for (let i = 0; i < this.inputs.length; i++) {\\n            if (this.inputs[i] instanceof GPUTexture) {\\n                inputs.push(`@group(0) @binding(${i}) var inputTexture${i}: texture_2d<f32>;`);\\n            }\\n            else if (this.inputs[i] instanceof GPUExternalTexture) {\\n                inputs.push(`@group(0) @binding(${i}) var inputTexture${i}: texture_external;`);\\n            }\\n            else if (this.inputs[i] instanceof GPUBuffer) {\\n                inputs.push(`@group(0) @binding(${i}) var<storage, read_write> inputBuffer${i}: array<vec4f>;`);\\n            }\\n            else {\\n                console.log(this.inputs[i]);\\n                throw new Error(\\\"Input is undefined or non of the correct input type\\\");\\n            }\\n        }\\n        //  console.log(\\\"This layer\\\", this.label);\\n        // console.log(this.inputs.length);\\n        this.uniforms.forEach((uniform, i) => {\\n            inputs.push(`@group(0) @binding(${i + this.inputs.length}) var <uniform> ${uniform.name}: ${uniform.type};`);\\n        });\\n        inputs.push(`@group(0) @binding(${this.inputs.length + this.uniforms.length}) var <storage, read_write> outputBuffer: array<vec4f>;`);\\n        return inputs.join('\\\\n');\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            compute: {\\n                module: this.shader,\\n                entryPoint: 'main',\\n            },\\n        };\\n    }\\n    defaultSetup() {\\n        this.pipeline = this.device.createComputePipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n    }\\n    lazyLoadSetup() {\\n    }\\n    run() {\\n        const encoder = this.device.createCommandEncoder({ label: this.label });\\n        if (!this.pipeline)\\n            this.lazyLoadSetup();\\n        const pass = encoder.beginComputePass({ label: this.label });\\n        pass.setPipeline(this.pipeline);\\n        if (this.hasExternalTexture()) {\\n            this.bindGroup = this.defaultBindGroup();\\n        }\\n        if (this.bindGroup) {\\n            pass.setBindGroup(0, this.bindGroup);\\n        }\\n        // Dividing into work groups speeds up inference. If width or height aren't cleandly divided by work groups, we round to the nearest multiple of work-groups\\n        // Physically, this means shaving a few pixels (up to num_work_groups-1) off the bottom and right edges of the canvas but users shouldn't notice?\\n        pass.dispatchWorkgroups(Math.floor(this.resolution.width / this.num_work_groups), Math.floor(this.resolution.height / this.num_work_groups));\\n        pass.end();\\n        this.device.queue.submit([encoder.finish()]);\\n    }\\n}\\nexports[\\\"default\\\"] = ComputeLayer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/base_compute_layer.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/base_layer.ts\":\n/*!**********************************!*\\\n  !*** ./src/layers/base_layer.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, exports) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nclass Layer {\\n    constructor(inputs, output, weights) {\\n        this.context = globalThis.context;\\n        this.device = this.context.device;\\n        this.resolution = this.context.resolution;\\n        this.inputs = inputs;\\n        this.output = output;\\n        this.uniforms = [];\\n        this.buffers = {};\\n        this.weights = weights;\\n    }\\n    createUniform(name, type) {\\n        this.uniforms.push({ name, type });\\n    }\\n    setUniform(name, value) {\\n        const buffer = this.device.createBuffer({\\n            label: `layer-${this.label}-buffer-${name}`,\\n            size: value.byteLength,\\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\\n        });\\n        this.device.queue.writeBuffer(buffer, /*bufferOffset=*/ 0, value);\\n        this.buffers[name] = buffer;\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        this.uniforms.forEach((uniform, i) => {\\n            entries.push({\\n                binding: i + this.inputs.length,\\n                resource: {\\n                    buffer: this.buffers[uniform.name]\\n                }\\n            });\\n        });\\n        if (this.output instanceof GPUBuffer) {\\n            entries.push({\\n                binding: this.inputs.length + this.uniforms.length,\\n                resource: {\\n                    buffer: this.output\\n                }\\n            });\\n        }\\n        if (entries.length === 0)\\n            return null;\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n    hasExternalTexture() {\\n        for (const input of this.inputs) {\\n            if (input instanceof GPUExternalTexture)\\n                return true;\\n        }\\n        return false;\\n    }\\n    lazyLoadSetup() { }\\n    run() { }\\n}\\nexports[\\\"default\\\"] = Layer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/base_layer.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/base_render_layer.ts\":\n/*!*****************************************!*\\\n  !*** ./src/layers/base_render_layer.ts ***!\n  \\*****************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_layer_1 = __webpack_require__(/*! ./base_layer */ \\\"./src/layers/base_layer.ts\\\");\\nclass RenderLayer extends base_layer_1.default {\\n    constructor(inputs, output, weights) {\\n        super(inputs, output, weights);\\n        this.vertexScale = this.context.resolution;\\n    }\\n    defaultVertexShader() {\\n        return `\\n        \\n             struct VertexShaderOutput {\\n                @builtin(position) position: vec4f,\\n                @location(0) tex_coord: vec2f,\\n              };\\n\\n            @vertex\\n            fn vertexMain( @builtin(vertex_index) vertexIndex : u32) ->  VertexShaderOutput{\\n                let pos = array(\\n                // 1st triangle\\n                vec2f( -1.0,  -1.0),  // center\\n                vec2f( 1.0,  -1.0),  // right, center\\n                vec2f( -1.0,  1.0),  // center, top\\n             \\n                // 2st triangle\\n                vec2f( -1.0,  1.0),  // center, top\\n                vec2f( 1.0,  -1.0),  // right, center\\n                vec2f( 1.0,  1.0),  // right, top\\n              );\\n             \\n              var vsOutput: VertexShaderOutput;\\n              let xy = pos[vertexIndex];\\n              vsOutput.position = vec4f(xy, 0.0, 1.0);\\n              vsOutput.tex_coord = xy*0.5 + 0.5;\\n              vsOutput.tex_coord.y = - 1.0* vsOutput.tex_coord.y  + 1.0;\\n               vsOutput.tex_coord.x =  vsOutput.tex_coord.x*${this.vertexScale.width};\\n               vsOutput.tex_coord.y =  vsOutput.tex_coord.y*${this.vertexScale.height};\\n              return vsOutput;\\n            }\\n        `;\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            vertex: {\\n                module: this.shader,\\n                entryPoint: 'vertexMain',\\n            },\\n            fragment: {\\n                module: this.shader,\\n                entryPoint: 'fragmentMain',\\n                targets: [{ format: this.output.format }],\\n            },\\n        };\\n    }\\n    defaultSetup() {\\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\\n    }\\n    defaultRenderPassDescriptor() {\\n        return {\\n            label: `${this.label}-render-pass`,\\n            colorAttachments: [\\n                {\\n                    view: this.output.createView(),\\n                    clearValue: [0, 0, 0, 1],\\n                    loadOp: 'clear',\\n                    storeOp: 'store',\\n                },\\n            ],\\n        };\\n    }\\n    createStandardShader(fragmentShader) {\\n        return this.device.createShaderModule({\\n            label: `${this.label}-shader`,\\n            code: `\\n          \\n              ${this.defaultVertexShader()}\\n              \\n              ${this.fragmentShaderInputs()}\\n              \\n              ${fragmentShader}\\n        `\\n        });\\n    }\\n    fragmentShaderInputs() {\\n        const inputs = [];\\n        for (let i = 0; i < this.inputs.length; i++) {\\n            let type = (this.inputs[i] instanceof GPUTexture) ? 'texture_2d<f32>' : 'texture_external';\\n            inputs.push(`@group(0) @binding(0) var inputTexture${i}: ${type};`);\\n        }\\n        this.uniforms.forEach((uniform, i) => {\\n            inputs.push(`@group(0) @binding(${i + this.inputs.length}) var <uniform> ${uniform.name}: ${uniform.type};`);\\n        });\\n        return inputs.join('\\\\n');\\n    }\\n    run() {\\n        const encoder = this.device.createCommandEncoder({ label: this.label });\\n        if (!this.pipeline)\\n            this.lazyLoadSetup();\\n        const pass = encoder.beginRenderPass(this.renderPassDescriptor);\\n        pass.setPipeline(this.pipeline);\\n        if (this.hasExternalTexture()) {\\n            this.bindGroup = this.defaultBindGroup();\\n        }\\n        if (this.bindGroup) {\\n            pass.setBindGroup(0, this.bindGroup);\\n        }\\n        pass.draw(6); // call our vertex shader 6 times\\n        pass.end();\\n        this.device.queue.submit([encoder.finish()]);\\n    }\\n    setOutput(outputTexture) {\\n        this.output = outputTexture;\\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\\n    }\\n}\\nexports[\\\"default\\\"] = RenderLayer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/base_render_layer.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/utils/gaussian.ts\":\n/*!**************************************!*\\\n  !*** ./src/layers/utils/gaussian.ts ***!\n  \\**************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass GuassianLayer extends base_render_layer_1.default {\\n    constructor(inputTextures, outputTexture) {\\n        super(inputTextures, outputTexture);\\n        this.label = \\\"Gaussian\\\";\\n        this.createUniform(\\\"gaussian\\\", \\\"array<vec3f, 3>\\\");\\n        this.createUniform(\\\"kernel_offsets\\\", \\\"array<vec4f, 9>\\\");\\n        this.shader = this.createStandardShader(`\\n        \\n                  @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\\n                  \\n                     var val  = 0.0;\\n                      \\n                     for(var i = 0u; i < 3; i++){\\n                     \\n                        let a = vec3f(\\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x\\n                        );\\n                        \\n                        val += dot(a, gaussian[i]);\\n                      \\n                    } \\n                  \\n                    \\n                    return vec4f(val, val, val, 1.0);\\n                  }                 \\n        `);\\n        this.setUniform(\\\"gaussian\\\", new Float32Array([\\n            0.0675, 0.125, 0.0675, 0.0,\\n            0.125, 0.250, 0.1250, 0.0,\\n            0.0675, 0.125, 0.0675, 0.0\\n        ]));\\n        this.setUniform(\\\"kernel_offsets\\\", new Float32Array([\\n            -1, -1, 0, 0,\\n            0, -1, 0, 0,\\n            1, -1, 0, 0,\\n            -1, 0, 0, 0,\\n            0, 0, 0, 0,\\n            1, 0, 0, 0,\\n            -1, 1, 0, 0,\\n            0, 1, 0, 0,\\n            1, 1, 0, 0,\\n        ]));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = GuassianLayer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/utils/gaussian.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/layers/utils/rgb_2_yuv.ts\":\n/*!***************************************!*\\\n  !*** ./src/layers/utils/rgb_2_yuv.ts ***!\n  \\***************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass RGB2YUV extends base_render_layer_1.default {\\n    constructor(inputTextures, outputTexture) {\\n        super(inputTextures, outputTexture);\\n        this.createUniform(\\\"rgb2yuv\\\", \\\"mat3x3f\\\");\\n        this.shader = this.createStandardShader(`\\n        \\n               @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\\n              \\n                    let color = textureLoad(inputTexture0, vec2<i32>(input.tex_coord), 0);       \\n                    let yuv = rgb2yuv*color.xyz;\\n          \\n                return vec4f(yuv, 1.0);\\n              }     \\n        `);\\n        this.setUniform(\\\"rgb2yuv\\\", new Float32Array([\\n            0.299, -0.1473, 0.615, 1.0,\\n            0.587, -.2886, -.51499, 1.0,\\n            0.114, 0.436, -.1001, 1.0\\n        ]));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = RGB2YUV;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/utils/rgb_2_yuv.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/main.ts\":\n/*!*********************!*\\\n  !*** ./src/main.ts ***!\n  \\*********************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst context_1 = __webpack_require__(/*! ./context */ \\\"./src/context.ts\\\");\\nconst renderer_1 = __webpack_require__(/*! ./renderer */ \\\"./src/renderer.ts\\\");\\nconst network_list_1 = __webpack_require__(/*! ./networks/network_list */ \\\"./src/networks/network_list.ts\\\");\\nconst utils_1 = __webpack_require__(/*! ./utils */ \\\"./src/utils.ts\\\");\\nclass WebSR {\\n    constructor(params) {\\n        if (!network_list_1.NetworkList[params.network_name])\\n            throw Error(`Network ${params.network_name} is not defined or implemented`);\\n        this.source = params.source;\\n        const source = this.source;\\n        this.resolution = params.resolution ? params.resolution : {\\n            width: (0, utils_1.getSourceWidth)(source),\\n            height: (0, utils_1.getSourceHeight)(source)\\n        };\\n        const scale = network_list_1.NetworkScales[params.network_name];\\n        if (params.canvas)\\n            this.canvas = params.canvas;\\n        else {\\n            this.canvas = new HTMLCanvasElement();\\n            this.canvas.width = this.resolution.width * scale;\\n            this.canvas.height = this.resolution.height * scale;\\n        }\\n        this.scale = scale;\\n        this.context = new context_1.default(params.gpu, this.resolution, this.canvas, this.scale, this.debug);\\n        globalThis.context = this.context;\\n        this.network = new network_list_1.NetworkList[params.network_name](params.weights);\\n        this.renderer = new renderer_1.default(this.network, this.source);\\n    }\\n    switchNetwork(network, weights) {\\n        if (!network_list_1.NetworkList[network])\\n            throw Error(`Network ${network} is not defined or implemented`);\\n        this.network = new network_list_1.NetworkList[network](weights);\\n        this.renderer.switchNetwork(this.network);\\n    }\\n    static initWebGPU() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (!navigator.gpu)\\n                return false;\\n            const adapter = yield navigator.gpu.requestAdapter();\\n            if (!adapter)\\n                return false;\\n            const device = yield adapter.requestDevice();\\n            if (!device)\\n                return false;\\n            return device;\\n        });\\n    }\\n    start() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            yield this.renderer.start();\\n        });\\n    }\\n    stop() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            yield this.renderer.stop();\\n        });\\n    }\\n    render(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            yield this.renderer.render(source);\\n        });\\n    }\\n    destroy() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            yield this.renderer.stop();\\n            this.context.destroy();\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = WebSR;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/main.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/networks/anime4k/cnn-2x-l.ts\":\n/*!******************************************!*\\\n  !*** ./src/networks/anime4k/cnn-2x-l.ts ***!\n  \\******************************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \\\"./src/layers/anime4k/conv2d-3x4.ts\\\");\\nconst display_3c_1 = __webpack_require__(/*! ../../layers/anime4k/display_3c */ \\\"./src/layers/anime4k/display_3c.ts\\\");\\nconst conv2d_16x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-16x4 */ \\\"./src/layers/anime4k/conv2d-16x4.ts\\\");\\nconst conv2d_112x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-112x4 */ \\\"./src/layers/anime4k/conv2d-112x4.ts\\\");\\nconst conv2d_concat2_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-concat2 */ \\\"./src/layers/anime4k/conv2d-concat2.ts\\\");\\nconst utils_1 = __webpack_require__(/*! ../../utils */ \\\"./src/utils.ts\\\");\\nclass Anime4KCNN2XL extends base_network_1.default {\\n    constructor(weights) {\\n        super(weights);\\n    }\\n    model() {\\n        const layers = [];\\n        const weights = this.weights.layers;\\n        const context = this.context;\\n        layers.push(new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']));\\n        layers.push(new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf1'), weights['conv2d_tf1']));\\n        for (let i = 1; i < 7; i++) {\\n            let source = (i == 1) ? `conv2d_tf` : `conv2d_${i - 1}_tf`;\\n            layers.push(new conv2d_16x4_1.default([context.buffer(source), context.buffer(source + \\\"1\\\")], context.buffer(`conv2d_${i}_tf`), weights[`conv2d_${i}_tf`]));\\n            layers.push(new conv2d_16x4_1.default([context.buffer(source), context.buffer(source + \\\"1\\\")], context.buffer(`conv2d_${i}_tf1`), weights[`conv2d_${i}_tf1`]));\\n        }\\n        for (let c = 0; c < 3; c++) {\\n            const sources_0 = [];\\n            const sources_1 = [];\\n            for (let i = 0; i < 7; i++) {\\n                let source = (i == 0) ? `conv2d_tf` : `conv2d_${i}_tf`;\\n                sources_0.push(context.buffer(source));\\n                sources_1.push(context.buffer(source + \\\"1\\\"));\\n            }\\n            const dest = (c == 0) ? `conv2d_last_tf` : `conv2d_last_tf${c}`;\\n            layers.push(new conv2d_112x4_1.default(sources_0, context.buffer(`conv2d_last_${c}_pt1`), weights[dest], true));\\n            layers.push(new conv2d_112x4_1.default(sources_1, context.buffer(`conv2d_last_${c}_pt2`), weights[dest], false));\\n            layers.push(new conv2d_concat2_1.default([context.buffer(`conv2d_last_${c}_pt1`), context.buffer(`conv2d_last_${c}_pt2`)], context.buffer(dest), weights[dest]));\\n        }\\n        const paint = new display_3c_1.default([context.buffer('conv2d_last_tf'), context.buffer('conv2d_last_tf1'), context.buffer('conv2d_last_tf2'), context.input], context.texture('output'));\\n        layers.push(paint);\\n        return layers;\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if ((0, utils_1.isHTMLVideoElement)(source) || (0, utils_1.isVideoFrame)(source)) {\\n                this.context.input = this.context.device.importExternalTexture({ source });\\n            }\\n            else {\\n                const bitmap = (0, utils_1.isImageBitmap)(source) ? source : yield createImageBitmap(source);\\n                const width = (0, utils_1.getSourceWidth)(source);\\n                const height = (0, utils_1.getSourceHeight)(source);\\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \\\"rgba8unorm\\\" }) }, [width, height]);\\n                this.context.input = this.context.texture('input');\\n            }\\n            this.layers[0].inputs[0] = this.context.input;\\n            this.layers[1].inputs[0] = this.context.input;\\n            this.layers[this.layers.length - 1].inputs[3] = this.context.input;\\n            this.layers[0].lazyLoadSetup();\\n            this.layers[this.layers.length - 1].lazyLoadSetup();\\n            this.layers.forEach(function (layer) {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KCNN2XL;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-2x-l.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/networks/anime4k/cnn-2x-m.ts\":\n/*!******************************************!*\\\n  !*** ./src/networks/anime4k/cnn-2x-m.ts ***!\n  \\******************************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \\\"./src/layers/anime4k/conv2d-3x4.ts\\\");\\nconst conv2d_8x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-8x4 */ \\\"./src/layers/anime4k/conv2d-8x4.ts\\\");\\nconst conv2d_56x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-56x4 */ \\\"./src/layers/anime4k/conv2d-56x4.ts\\\");\\nconst display_3c_1 = __webpack_require__(/*! ../../layers/anime4k/display_3c */ \\\"./src/layers/anime4k/display_3c.ts\\\");\\nconst utils_1 = __webpack_require__(/*! ../../utils */ \\\"./src/utils.ts\\\");\\nclass Anime4KCNN2XM extends base_network_1.default {\\n    constructor(weights) {\\n        super(weights);\\n    }\\n    model() {\\n        const layers = [];\\n        const weights = this.weights.layers;\\n        const context = this.context;\\n        const conv2d_tf = new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']);\\n        const conv2d_1_tf = new conv2d_8x4_1.default([context.buffer('conv2d_tf')], context.buffer('conv2d_1_tf'), weights['conv2d_1_tf']);\\n        const conv2d_2_tf = new conv2d_8x4_1.default([context.buffer('conv2d_1_tf')], context.buffer('conv2d_2_tf'), weights['conv2d_2_tf']);\\n        const conv2d_3_tf = new conv2d_8x4_1.default([context.buffer('conv2d_2_tf')], context.buffer('conv2d_3_tf'), weights['conv2d_3_tf']);\\n        const conv2d_4_tf = new conv2d_8x4_1.default([context.buffer('conv2d_3_tf')], context.buffer('conv2d_4_tf'), weights['conv2d_4_tf']);\\n        const conv2d_5_tf = new conv2d_8x4_1.default([context.buffer('conv2d_4_tf')], context.buffer('conv2d_5_tf'), weights['conv2d_5_tf']);\\n        const conv2d_6_tf = new conv2d_8x4_1.default([context.buffer('conv2d_5_tf')], context.buffer('conv2d_6_tf'), weights['conv2d_6_tf']);\\n        const conv2d_7_tf = new conv2d_56x4_1.default([context.buffer('conv2d_tf'), context.buffer('conv2d_1_tf'), context.buffer('conv2d_2_tf'), context.buffer('conv2d_3_tf'), context.buffer('conv2d_4_tf'), context.buffer('conv2d_5_tf'), context.buffer('conv2d_6_tf')], context.buffer('conv2d_7_tf'), weights['conv2d_7_tf']);\\n        const conv2d_7_tf1 = new conv2d_56x4_1.default([context.buffer('conv2d_tf'), context.buffer('conv2d_1_tf'), context.buffer('conv2d_2_tf'), context.buffer('conv2d_3_tf'), context.buffer('conv2d_4_tf'), context.buffer('conv2d_5_tf'), context.buffer('conv2d_6_tf')], context.buffer('conv2d_7_tf1'), weights['conv2d_7_tf1']);\\n        const conv2d_7_tf2 = new conv2d_56x4_1.default([context.buffer('conv2d_tf'), context.buffer('conv2d_1_tf'), context.buffer('conv2d_2_tf'), context.buffer('conv2d_3_tf'), context.buffer('conv2d_4_tf'), context.buffer('conv2d_5_tf'), context.buffer('conv2d_6_tf')], context.buffer('conv2d_7_tf2'), weights['conv2d_7_tf2']);\\n        const paint = new display_3c_1.default([context.buffer('conv2d_7_tf'), context.buffer('conv2d_7_tf1'), context.buffer('conv2d_7_tf2'), context.input], context.texture('output'));\\n        layers.push(conv2d_tf, conv2d_1_tf, conv2d_2_tf, conv2d_3_tf, conv2d_4_tf, conv2d_5_tf, conv2d_6_tf, conv2d_7_tf, conv2d_7_tf1, conv2d_7_tf2, paint);\\n        return layers;\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if ((0, utils_1.isHTMLVideoElement)(source) || (0, utils_1.isVideoFrame)(source)) {\\n                this.context.input = this.context.device.importExternalTexture({ source });\\n            }\\n            else {\\n                const bitmap = (0, utils_1.isImageBitmap)(source) ? source : yield createImageBitmap(source);\\n                const width = (0, utils_1.getSourceWidth)(source);\\n                const height = (0, utils_1.getSourceHeight)(source);\\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \\\"rgba8unorm\\\" }) }, [width, height]);\\n                this.context.input = this.context.texture('input');\\n            }\\n            this.layers[0].inputs[0] = this.context.input;\\n            this.layers[this.layers.length - 1].inputs[3] = this.context.input;\\n            this.layers[0].lazyLoadSetup();\\n            this.layers[this.layers.length - 1].lazyLoadSetup();\\n            this.layers.forEach(function (layer) {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KCNN2XM;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-2x-m.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/networks/anime4k/cnn-2x-s.ts\":\n/*!******************************************!*\\\n  !*** ./src/networks/anime4k/cnn-2x-s.ts ***!\n  \\******************************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \\\"./src/layers/anime4k/conv2d-3x4.ts\\\");\\nconst conv2d_8x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-8x4 */ \\\"./src/layers/anime4k/conv2d-8x4.ts\\\");\\nconst display_1 = __webpack_require__(/*! ../../layers/anime4k/display */ \\\"./src/layers/anime4k/display.ts\\\");\\nconst utils_1 = __webpack_require__(/*! ../../utils */ \\\"./src/utils.ts\\\");\\nclass Anime4KCNN2XS extends base_network_1.default {\\n    constructor(weights) {\\n        super(weights);\\n    }\\n    model() {\\n        const layers = [];\\n        const weights = this.weights.layers;\\n        const context = this.context;\\n        const conv2d_tf = new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']);\\n        const conv2d_1_tf = new conv2d_8x4_1.default([context.buffer('conv2d_tf')], context.buffer('conv2d_1_tf'), weights['conv2d_1_tf']);\\n        const conv2d_2_tf = new conv2d_8x4_1.default([context.buffer('conv2d_1_tf')], context.buffer('conv2d_2_tf'), weights['conv2d_2_tf']);\\n        const conv2d_last_tf = new conv2d_8x4_1.default([context.buffer('conv2d_2_tf')], context.buffer('conv2d_last_tf'), weights['conv2d_last_tf']);\\n        const paint = new display_1.default([context.buffer('conv2d_last_tf'), context.input], context.texture('output'));\\n        layers.push(conv2d_tf, conv2d_1_tf, conv2d_2_tf, conv2d_last_tf, paint);\\n        return layers;\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if ((0, utils_1.isHTMLVideoElement)(source) || (0, utils_1.isVideoFrame)(source)) {\\n                this.context.input = this.context.device.importExternalTexture({ source });\\n            }\\n            else {\\n                const bitmap = (0, utils_1.isImageBitmap)(source) ? source : yield createImageBitmap(source);\\n                const width = (0, utils_1.getSourceWidth)(source);\\n                const height = (0, utils_1.getSourceHeight)(source);\\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \\\"rgba8unorm\\\" }) }, [width, height]);\\n                this.context.input = this.context.texture('input');\\n            }\\n            this.layers[0].inputs[0] = this.context.input;\\n            this.layers[this.layers.length - 1].inputs[1] = this.context.input;\\n            this.layers[0].lazyLoadSetup();\\n            this.layers[this.layers.length - 1].lazyLoadSetup();\\n            this.layers.forEach(function (layer) {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KCNN2XS;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-2x-s.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/networks/anime4k/cnn-restore-l.ts\":\n/*!***********************************************!*\\\n  !*** ./src/networks/anime4k/cnn-restore-l.ts ***!\n  \\***********************************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \\\"./src/layers/anime4k/conv2d-3x4.ts\\\");\\nconst conv2d_16x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-16x4 */ \\\"./src/layers/anime4k/conv2d-16x4.ts\\\");\\nconst display_1x_1 = __webpack_require__(/*! ../../layers/anime4k/display_1x */ \\\"./src/layers/anime4k/display_1x.ts\\\");\\nconst utils_1 = __webpack_require__(/*! ../../utils */ \\\"./src/utils.ts\\\");\\nclass Anime4KCNNRL extends base_network_1.default {\\n    constructor(weights) {\\n        super(weights);\\n    }\\n    model() {\\n        const layers = [];\\n        const weights = this.weights.layers;\\n        const context = this.context;\\n        layers.push(new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']));\\n        layers.push(new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf1'), weights['conv2d_tf1']));\\n        for (let i = 1; i < 4; i++) {\\n            let source = (i == 1) ? `conv2d_tf` : `conv2d_${i - 1}_tf`;\\n            layers.push(new conv2d_16x4_1.default([context.buffer(source), context.buffer(source + \\\"1\\\")], context.buffer(`conv2d_${i}_tf`), weights[`conv2d_${i}_tf`]));\\n            layers.push(new conv2d_16x4_1.default([context.buffer(source), context.buffer(source + \\\"1\\\")], context.buffer(`conv2d_${i}_tf1`), weights[`conv2d_${i}_tf1`]));\\n        }\\n        layers.push(new conv2d_16x4_1.default([context.buffer('conv2d_3_tf'), context.buffer('conv2d_3_tf1')], context.buffer(`conv2d_out_tf`), weights[`conv2d_out_tf`]));\\n        const paint = new display_1x_1.default([context.buffer('conv2d_out_tf'), context.input], context.texture('output'));\\n        layers.push(paint);\\n        return layers;\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if ((0, utils_1.isHTMLVideoElement)(source) || (0, utils_1.isVideoFrame)(source)) {\\n                this.context.input = this.context.device.importExternalTexture({ source });\\n            }\\n            else {\\n                const bitmap = (0, utils_1.isImageBitmap)(source) ? source : yield createImageBitmap(source);\\n                const width = (0, utils_1.getSourceWidth)(source);\\n                const height = (0, utils_1.getSourceHeight)(source);\\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \\\"rgba8unorm\\\" }) }, [width, height]);\\n                this.context.input = this.context.texture('input');\\n            }\\n            this.layers[0].inputs[0] = this.context.input;\\n            this.layers[1].inputs[0] = this.context.input;\\n            this.layers[this.layers.length - 1].inputs[1] = this.context.input;\\n            this.layers.forEach(function (layer) {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KCNNRL;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-restore-l.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/networks/anime4k/cnn-restore-m.ts\":\n/*!***********************************************!*\\\n  !*** ./src/networks/anime4k/cnn-restore-m.ts ***!\n  \\***********************************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \\\"./src/layers/anime4k/conv2d-3x4.ts\\\");\\nconst conv2d_8x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-8x4 */ \\\"./src/layers/anime4k/conv2d-8x4.ts\\\");\\nconst conv2d_56x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-56x4 */ \\\"./src/layers/anime4k/conv2d-56x4.ts\\\");\\nconst display_1x_1 = __webpack_require__(/*! ../../layers/anime4k/display_1x */ \\\"./src/layers/anime4k/display_1x.ts\\\");\\nconst utils_1 = __webpack_require__(/*! ../../utils */ \\\"./src/utils.ts\\\");\\nclass Anime4KCNNRM extends base_network_1.default {\\n    constructor(weights) {\\n        super(weights);\\n    }\\n    model() {\\n        const layers = [];\\n        const weights = this.weights.layers;\\n        const context = this.context;\\n        const conv2d_tf = new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']);\\n        const conv2d_1_tf = new conv2d_8x4_1.default([context.buffer('conv2d_tf')], context.buffer('conv2d_1_tf'), weights['conv2d_1_tf']);\\n        const conv2d_2_tf = new conv2d_8x4_1.default([context.buffer('conv2d_1_tf')], context.buffer('conv2d_2_tf'), weights['conv2d_2_tf']);\\n        const conv2d_3_tf = new conv2d_8x4_1.default([context.buffer('conv2d_2_tf')], context.buffer('conv2d_3_tf'), weights['conv2d_3_tf']);\\n        const conv2d_4_tf = new conv2d_8x4_1.default([context.buffer('conv2d_3_tf')], context.buffer('conv2d_4_tf'), weights['conv2d_4_tf']);\\n        const conv2d_5_tf = new conv2d_8x4_1.default([context.buffer('conv2d_4_tf')], context.buffer('conv2d_5_tf'), weights['conv2d_5_tf']);\\n        const conv2d_6_tf = new conv2d_8x4_1.default([context.buffer('conv2d_5_tf')], context.buffer('conv2d_6_tf'), weights['conv2d_6_tf']);\\n        const conv2d_out_tf = new conv2d_56x4_1.default([context.buffer('conv2d_tf'), context.buffer('conv2d_1_tf'), context.buffer('conv2d_2_tf'), context.buffer('conv2d_3_tf'), context.buffer('conv2d_4_tf'), context.buffer('conv2d_5_tf'), context.buffer('conv2d_6_tf')], context.buffer('conv2d_out_tf'), weights['conv2d_out_tf']);\\n        const paint = new display_1x_1.default([context.buffer('conv2d_out_tf'), context.input], context.texture('output'));\\n        layers.push(conv2d_tf, conv2d_1_tf, conv2d_2_tf, conv2d_3_tf, conv2d_4_tf, conv2d_5_tf, conv2d_6_tf, conv2d_out_tf, paint);\\n        return layers;\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if ((0, utils_1.isHTMLVideoElement)(source) || (0, utils_1.isVideoFrame)(source)) {\\n                this.context.input = this.context.device.importExternalTexture({ source });\\n            }\\n            else {\\n                const bitmap = (0, utils_1.isImageBitmap)(source) ? source : yield createImageBitmap(source);\\n                const width = (0, utils_1.getSourceWidth)(source);\\n                const height = (0, utils_1.getSourceHeight)(source);\\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \\\"rgba8unorm\\\" }) }, [width, height]);\\n                this.context.input = this.context.texture('input');\\n            }\\n            this.layers[0].inputs[0] = this.context.input;\\n            this.layers[1].inputs[0] = this.context.input;\\n            this.layers[this.layers.length - 1].inputs[1] = this.context.input;\\n            this.layers.forEach(function (layer) {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KCNNRM;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-restore-m.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/networks/anime4k/cnn-restore-s.ts\":\n/*!***********************************************!*\\\n  !*** ./src/networks/anime4k/cnn-restore-s.ts ***!\n  \\***********************************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \\\"./src/layers/anime4k/conv2d-3x4.ts\\\");\\nconst conv2d_8x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-8x4 */ \\\"./src/layers/anime4k/conv2d-8x4.ts\\\");\\nconst display_1x_1 = __webpack_require__(/*! ../../layers/anime4k/display_1x */ \\\"./src/layers/anime4k/display_1x.ts\\\");\\nconst utils_1 = __webpack_require__(/*! ../../utils */ \\\"./src/utils.ts\\\");\\nclass Anime4KCNNRS extends base_network_1.default {\\n    constructor(weights) {\\n        super(weights);\\n    }\\n    model() {\\n        const layers = [];\\n        const weights = this.weights.layers;\\n        const context = this.context;\\n        const conv2d_tf = new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']);\\n        const conv2d_1_tf = new conv2d_8x4_1.default([context.buffer('conv2d_tf')], context.buffer('conv2d_1_tf'), weights['conv2d_1_tf']);\\n        const conv2d_2_tf = new conv2d_8x4_1.default([context.buffer('conv2d_1_tf')], context.buffer('conv2d_2_tf'), weights['conv2d_2_tf']);\\n        const conv2d_last_tf = new conv2d_8x4_1.default([context.buffer('conv2d_2_tf')], context.buffer('conv2d_out_tf'), weights['conv2d_out_tf']);\\n        const paint = new display_1x_1.default([context.buffer('conv2d_out_tf'), context.input], context.texture('output'));\\n        layers.push(conv2d_tf, conv2d_1_tf, conv2d_2_tf, conv2d_last_tf, paint);\\n        return layers;\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if ((0, utils_1.isHTMLVideoElement)(source) || (0, utils_1.isVideoFrame)(source)) {\\n                this.context.input = this.context.device.importExternalTexture({ source });\\n            }\\n            else {\\n                const bitmap = (0, utils_1.isImageBitmap)(source) ? source : yield createImageBitmap(source);\\n                const width = (0, utils_1.getSourceWidth)(source);\\n                const height = (0, utils_1.getSourceHeight)(source);\\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \\\"rgba8unorm\\\" }) }, [width, height]);\\n                this.context.input = this.context.texture('input');\\n            }\\n            this.layers[0].inputs[0] = this.context.input;\\n            this.layers[this.layers.length - 1].inputs[1] = this.context.input;\\n            this.layers.forEach(function (layer) {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KCNNRS;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-restore-s.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/networks/base_network.ts\":\n/*!**************************************!*\\\n  !*** ./src/networks/base_network.ts ***!\n  \\**************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nclass NeuralNetwork {\\n    constructor(weights) {\\n        this.weights = weights;\\n        this.context = globalThis.context;\\n        this.layers = this.model();\\n    }\\n    model() {\\n        return [];\\n    }\\n    lastLayer() {\\n        return this.layers[this.layers.length - 1];\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            this.layers.forEach(layer => {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = NeuralNetwork;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/base_network.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/networks/network_list.ts\":\n/*!**************************************!*\\\n  !*** ./src/networks/network_list.ts ***!\n  \\**************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nexports.NetworkScales = exports.NetworkList = void 0;\\nconst cnn_2x_s_1 = __webpack_require__(/*! ./anime4k/cnn-2x-s */ \\\"./src/networks/anime4k/cnn-2x-s.ts\\\");\\nconst cnn_2x_m_1 = __webpack_require__(/*! ./anime4k/cnn-2x-m */ \\\"./src/networks/anime4k/cnn-2x-m.ts\\\");\\nconst cnn_2x_l_1 = __webpack_require__(/*! ./anime4k/cnn-2x-l */ \\\"./src/networks/anime4k/cnn-2x-l.ts\\\");\\nconst cnn_restore_l_1 = __webpack_require__(/*! ./anime4k/cnn-restore-l */ \\\"./src/networks/anime4k/cnn-restore-l.ts\\\");\\nconst cnn_restore_m_1 = __webpack_require__(/*! ./anime4k/cnn-restore-m */ \\\"./src/networks/anime4k/cnn-restore-m.ts\\\");\\nconst cnn_restore_s_1 = __webpack_require__(/*! ./anime4k/cnn-restore-s */ \\\"./src/networks/anime4k/cnn-restore-s.ts\\\");\\nconst poc_network_1 = __webpack_require__(/*! ./poc_network */ \\\"./src/networks/poc_network.ts\\\");\\nexports.NetworkList = {\\n    \\\"anime4k/cnn-2x-s\\\": cnn_2x_s_1.default,\\n    \\\"anime4k/cnn-2x-m\\\": cnn_2x_m_1.default,\\n    \\\"anime4k/cnn-2x-l\\\": cnn_2x_l_1.default,\\n    \\\"anime4k/cnn-restore-s\\\": cnn_restore_s_1.default,\\n    \\\"anime4k/cnn-restore-m\\\": cnn_restore_m_1.default,\\n    \\\"anime4k/cnn-restore-l\\\": cnn_restore_l_1.default,\\n    \\\"sb2702/blur-poc\\\": poc_network_1.default\\n};\\nexports.NetworkScales = {\\n    \\\"anime4k/cnn-2x-s\\\": 2,\\n    \\\"anime4k/cnn-2x-m\\\": 2,\\n    \\\"anime4k/cnn-2x-l\\\": 2,\\n    \\\"anime4k/cnn-restore-s\\\": 1,\\n    \\\"anime4k/cnn-restore-m\\\": 1,\\n    \\\"anime4k/cnn-restore-l\\\": 1,\\n    \\\"sb2702/blur-poc\\\": 1\\n};\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/network_list.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/networks/poc_network.ts\":\n/*!*************************************!*\\\n  !*** ./src/networks/poc_network.ts ***!\n  \\*************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ./base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst rgb_2_yuv_1 = __webpack_require__(/*! ../layers/utils/rgb_2_yuv */ \\\"./src/layers/utils/rgb_2_yuv.ts\\\");\\nconst gaussian_1 = __webpack_require__(/*! ../layers/utils/gaussian */ \\\"./src/layers/utils/gaussian.ts\\\");\\nclass PoCNetwork extends base_network_1.default {\\n    constructor() {\\n        super();\\n    }\\n    model() {\\n        const layers = [];\\n        const context = this.context;\\n        layers.push(new rgb_2_yuv_1.default([context.texture('input')], context.texture('yuv')));\\n        layers.push(new gaussian_1.default([context.texture('yuv')], context.texture('output')));\\n        return layers;\\n    }\\n}\\nexports[\\\"default\\\"] = PoCNetwork;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/poc_network.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/renderer.ts\":\n/*!*************************!*\\\n  !*** ./src/renderer.ts ***!\n  \\*************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"{\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst display_1 = __webpack_require__(/*! ./layers/anime4k/display */ \\\"./src/layers/anime4k/display.ts\\\");\\nconst base_render_layer_1 = __webpack_require__(/*! ./layers/base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nconst utils_1 = __webpack_require__(/*! ./utils */ \\\"./src/utils.ts\\\");\\nclass WebSRRenderer {\\n    constructor(network, source) {\\n        this.context = globalThis.context;\\n        this.network = network;\\n        this.source = source;\\n        this.active = false;\\n    }\\n    switchNetwork(network) {\\n        this.network = network;\\n    }\\n    start() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (this.context.destroyed) {\\n                throw new Error(\\\"WebSR instance was destroyed\\\");\\n            }\\n            this.active = true;\\n            yield this.renderStep();\\n        });\\n    }\\n    stop() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            this.active = false;\\n            if (this.vfc && this.source && (0, utils_1.isHTMLVideoElement)(this.source))\\n                this.source.cancelVideoFrameCallback(this.vfc);\\n        });\\n    }\\n    renderStep() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            const lastLayer = this.network.lastLayer();\\n            if (lastLayer instanceof display_1.default)\\n                lastLayer.setOutput(this.context.context.getCurrentTexture());\\n            yield this.render();\\n            if (this.active && this.source && (0, utils_1.isHTMLVideoElement)(this.source)) {\\n                this.vfc = this.source.requestVideoFrameCallback(this.renderStep.bind(this));\\n            }\\n        });\\n    }\\n    render(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            const lastLayer = this.network.lastLayer();\\n            if (lastLayer instanceof base_render_layer_1.default)\\n                lastLayer.setOutput(this.context.context.getCurrentTexture());\\n            yield this.network.feedForward(source ? source : this.source);\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = WebSRRenderer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/renderer.ts?\\n}\");\n\n/***/ }),\n\n/***/ \"./src/utils.ts\":\n/*!**********************!*\\\n  !*** ./src/utils.ts ***!\n  \\**********************/\n/***/ ((__unused_webpack_module, exports) => {\n\neval(\"{\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nexports.isMainThread = isMainThread;\\nexports.isHTMLVideoElement = isHTMLVideoElement;\\nexports.isHTMLImageElement = isHTMLImageElement;\\nexports.isImageBitmap = isImageBitmap;\\nexports.isVideoFrame = isVideoFrame;\\nexports.isVideoSource = isVideoSource;\\nexports.isImageSource = isImageSource;\\nexports.getSourceWidth = getSourceWidth;\\nexports.getSourceHeight = getSourceHeight;\\n/**\\n * Check if we're running on the main thread (not in a worker)\\n */\\nfunction isMainThread() {\\n    return typeof HTMLVideoElement !== 'undefined';\\n}\\n/**\\n * Check if a source is a video element (main thread only)\\n */\\nfunction isHTMLVideoElement(source) {\\n    return typeof HTMLVideoElement !== 'undefined' && source instanceof HTMLVideoElement;\\n}\\n/**\\n * Check if a source is an image element (main thread only)\\n */\\nfunction isHTMLImageElement(source) {\\n    return typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement;\\n}\\n/**\\n * Check if a source is an ImageBitmap (works in both contexts)\\n */\\nfunction isImageBitmap(source) {\\n    return typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap;\\n}\\n/**\\n * Check if a source is a VideoFrame (worker context)\\n */\\nfunction isVideoFrame(source) {\\n    return typeof VideoFrame !== 'undefined' && source instanceof VideoFrame;\\n}\\n/**\\n * Check if a source is any type of video source\\n */\\nfunction isVideoSource(source) {\\n    return isHTMLVideoElement(source) || isVideoFrame(source);\\n}\\n/**\\n * Check if a source is any type of image source\\n */\\nfunction isImageSource(source) {\\n    return isHTMLImageElement(source) || isImageBitmap(source);\\n}\\n/**\\n * Get the width of a media source\\n */\\nfunction getSourceWidth(source) {\\n    if (isHTMLVideoElement(source))\\n        return source.videoWidth;\\n    if (isHTMLImageElement(source))\\n        return source.naturalWidth;\\n    if (isVideoFrame(source))\\n        return source.displayWidth;\\n    if (isImageBitmap(source))\\n        return source.width;\\n    return 0;\\n}\\n/**\\n * Get the height of a media source\\n */\\nfunction getSourceHeight(source) {\\n    if (isHTMLVideoElement(source))\\n        return source.videoHeight;\\n    if (isHTMLImageElement(source))\\n        return source.naturalHeight;\\n    if (isVideoFrame(source))\\n        return source.displayHeight;\\n    if (isImageBitmap(source))\\n        return source.height;\\n    return 0;\\n}\\n\\n\\n//# sourceURL=webpack://WebSR/./src/utils.ts?\\n}\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(\"./src/main.ts\");\n/******/ \t__webpack_exports__ = __webpack_exports__[\"default\"];\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"../../../"}